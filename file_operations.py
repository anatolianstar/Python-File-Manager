"""
File Operations Module
Dosya y√∂netimi i≈ülemlerini i√ßerir
"""

import os
import shutil
import tkinter as tk
from tkinter import messagebox, filedialog, simpledialog
from pathlib import Path
import json
import hashlib
import time
import stat
from collections import defaultdict

class FileOperations:
    def __init__(self, gui_manager):
        self.gui = gui_manager
        self.target_path = "D:/"  # Default hedef klas√∂r
        self.source_path = ""
        self.current_path = self.target_path
        self.navigation_history = []
        self.history_index = -1
        self.clipboard = []
        self.clipboard_operation = None  # 'copy' veya 'cut'
        self.sort_column = None
        self.sort_reverse = False
        
        # Dosya kategorileri
        self.file_categories = self.get_file_categories()
        
        # GUI deƒüi≈ükenlerini g√ºncelle
        self.gui.target_var.set(self.target_path)
        self.gui.current_path_var.set(self.current_path)
        
        # Ayarlarƒ± y√ºkle
        self.load_settings()
        
        # Drag & Drop verisi
        self.drag_data = {"item": None, "x": 0, "y": 0}
        
        # ƒ∞lk y√ºkleme
        self.refresh_target()
        
        # Drag & Drop √∂zelliƒüini ayarla
        self.setup_drag_drop()
        
        # Target tree'ye focus ver
        self.gui.target_tree.focus_set()
        
    def get_file_categories(self):
        """Dosya kategorilerini tanƒ±mla"""
        return {
            'images': {
                'extensions': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg', '.ico'],
                'folder': 'Resimler',
                'subfolders': {
                    '.jpg': 'JPG', '.jpeg': 'JPG', '.png': 'PNG', '.gif': 'GIF',
                    '.bmp': 'BMP', '.tiff': 'TIFF', '.webp': 'WEBP', '.svg': 'SVG', '.ico': 'ICO'
                }
            },
            'documents': {
                'extensions': ['.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt'],
                'folder': 'Belgeler',
                'subfolders': {
                    '.pdf': 'PDF', '.doc': 'DOC', '.docx': 'DOCX', '.txt': 'Metin', '.rtf': 'RTF', '.odt': 'ODT'
                }
            },
            'spreadsheets': {
                'extensions': ['.xls', '.xlsx', '.csv', '.ods'],
                'folder': 'Excel',
                'subfolders': {
                    '.xls': 'XLS', '.xlsx': 'XLSX', '.csv': 'CSV', '.ods': 'ODS'
                }
            },
            'archives': {
                'extensions': ['.zip', '.rar', '.7z', '.tar', '.gz'],
                'folder': 'Arsiv',
                'subfolders': {
                    '.zip': 'ZIP', '.rar': 'RAR', '.7z': '7Z', '.tar': 'TAR', '.gz': 'GZ'
                }
            },
            'programs': {
                'extensions': ['.exe', '.msi', '.deb', '.rpm', '.dmg'],
                'folder': 'Programlar',
                'subfolders': {
                    '.exe': 'EXE', '.msi': 'MSI', '.deb': 'DEB', '.rpm': 'RPM', '.dmg': 'DMG'
                }
            },
            'cad': {
                'extensions': ['.dwg', '.dxf', '.step', '.iges'],
                'folder': 'CAD',
                'subfolders': {
                    '.dwg': 'DWG', '.dxf': 'DXF', '.step': 'STEP', '.iges': 'IGES'
                }
            },
            'video': {
                'extensions': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv'],
                'folder': 'Videolar',
                'subfolders': {
                    '.mp4': 'MP4', '.avi': 'AVI', '.mkv': 'MKV', '.mov': 'MOV', '.wmv': 'WMV', '.flv': 'FLV'
                }
            },
            'audio': {
                'extensions': ['.mp3', '.wav', '.flac', '.aac', '.ogg'],
                'folder': 'Muzik',
                'subfolders': {
                    '.mp3': 'MP3', '.wav': 'WAV', '.flac': 'FLAC', '.aac': 'AAC', '.ogg': 'OGG'
                }
            }
        }
    
    def get_file_category(self, file_path):
        """Dosyanƒ±n kategorisini belirle"""
        file_ext = Path(file_path).suffix.lower()
        
        for category, info in self.file_categories.items():
            if file_ext in info['extensions']:
                return category, info
        
        # Bilinmeyen uzantƒ± i√ßin otomatik kategori olu≈ütur
        if file_ext:
            folder_name = f"{file_ext.replace('.', '').upper()}"
            auto_category = {
                'extensions': [file_ext],
                'folder': folder_name,
                'subfolders': {file_ext: file_ext.replace('.', '').upper()}
            }
            return 'unknown', auto_category
        else:
            # Uzantƒ±sƒ±z dosyalar
            return 'unknown', {
                'extensions': [''],
                'folder': 'Uzantisiz_Dosyalar',
                'subfolders': {'': 'Uzantisiz'}
            }
    
    def select_source_folder(self):
        """Kaynak klas√∂r se√ßimi"""
        folder = filedialog.askdirectory(title="Kaynak Klas√∂r Se√ßin")
        if folder:
            self.source_path = folder
            self.gui.source_var.set(folder)
            self.gui.status_var.set(f"Kaynak klas√∂r se√ßildi: {folder}")
            
            # Kaynak tree'yi temizle
            self.gui.source_tree.delete(*self.gui.source_tree.get_children())
        else:
            self.gui.status_var.set("Kaynak klas√∂r se√ßimi iptal edildi.")
    
    def select_target_folder(self):
        """Hedef klas√∂r se√ßimi"""
        folder = filedialog.askdirectory(title="Hedef SSD Se√ßin", initialdir=self.target_path)
        if folder:
            self.target_path = folder
            self.current_path = folder
            self.gui.target_var.set(folder)
            self.gui.current_path_var.set(folder)
            
            # Ayarlarƒ± kaydet
            self.save_settings()
            
            # Hedef klas√∂r√º yenile
            self.refresh_target()
            self.gui.status_var.set(f"Hedef klas√∂r deƒüi≈ütirildi: {folder}")
        else:
            self.gui.status_var.set("Hedef klas√∂r se√ßimi iptal edildi.")
    
    def add_to_history(self, path):
        """Navigasyon ge√ßmi≈üine ekle"""
        if self.history_index < len(self.navigation_history) - 1:
            self.navigation_history = self.navigation_history[:self.history_index + 1]
        
        if not self.navigation_history or self.navigation_history[-1] != path:
            self.navigation_history.append(path)
            self.history_index = len(self.navigation_history) - 1
    
    def go_back(self):
        """Geri git"""
        if self.history_index > 0:
            self.history_index -= 1
            self.current_path = self.navigation_history[self.history_index]
            self.gui.current_path_var.set(self.current_path)
            self.refresh_target(add_to_history=False)
    
    def go_up(self):
        """√úst klas√∂re git"""
        parent = os.path.dirname(self.current_path)
        if parent != self.current_path:
            self.current_path = parent
            self.gui.current_path_var.set(parent)
            self.refresh_target()
    
    def go_home(self):
        """Ana klas√∂re git"""
        self.current_path = self.target_path
        self.gui.current_path_var.set(self.target_path)
        self.refresh_target()
    
    def navigate_to_path(self, event=None):
        """Belirtilen yola git"""
        path = self.gui.current_path_var.get()
        if os.path.exists(path) and os.path.isdir(path):
            self.current_path = path
            self.refresh_target()
        else:
            messagebox.showerror("Hata", "Ge√ßersiz klas√∂r yolu!")
            self.gui.current_path_var.set(self.current_path)
    
    def refresh_target(self, add_to_history=True):
        """Hedef klas√∂r√º yenile"""
        # Ge√ßerli yol kontrol√º
        if not os.path.exists(self.current_path):
            self.current_path = self.target_path
            self.gui.current_path_var.set(self.current_path)
        
        if add_to_history:
            self.add_to_history(self.current_path)
        
        # Tree'yi temizle
        self.gui.target_tree.delete(*self.gui.target_tree.get_children())
        
        try:
            items = []
            
            # Klas√∂rleri ekle
            for item in os.listdir(self.current_path):
                if self.is_hidden_file(item):
                    continue
                    
                item_path = os.path.join(self.current_path, item)
                
                if os.path.isdir(item_path):
                    try:
                        modified_time = self.get_modified_time(item_path)
                        items.append((item, "üìÅ Klas√∂r", "", modified_time, item_path, True))
                    except:
                        items.append((item, "üìÅ Klas√∂r", "", "Bilinmiyor", item_path, True))
            
            # Dosyalarƒ± ekle
            for item in os.listdir(self.current_path):
                if self.is_hidden_file(item):
                    continue
                    
                item_path = os.path.join(self.current_path, item)
                
                if os.path.isfile(item_path):
                    try:
                        file_size = os.path.getsize(item_path)
                        file_ext = Path(item_path).suffix.upper()
                        modified_time = self.get_modified_time(item_path)
                        items.append((item, file_ext, self.format_size(file_size), modified_time, item_path, False))
                    except:
                        items.append((item, "Dosya", "Bilinmiyor", "Bilinmiyor", item_path, False))
            
            # Sƒ±ralama uygula
            if self.sort_column:
                items.sort(key=self.get_sort_key, reverse=self.sort_reverse)
            
            # Tree'ye ekle
            for item_name, item_type, size, modified, full_path, is_dir in items:
                self.gui.target_tree.insert('', 'end', text=item_name, 
                                          values=(size, item_type, modified),
                                          tags=('directory' if is_dir else 'file',))
            
            self.gui.status_var.set(f"üìÅ {len([i for i in items if i[5]])} klas√∂r, üìÑ {len([i for i in items if not i[5]])} dosya")
            
        except PermissionError:
            messagebox.showerror("Hata", "Bu klas√∂re eri≈üim izniniz yok!")
        except Exception as e:
            messagebox.showerror("Hata", f"Klas√∂r y√ºklenirken hata: {e}")
    
    def get_modified_time(self, file_path):
        """Dosya deƒüi≈ütirilme zamanƒ±nƒ± al"""
        try:
            import time
            timestamp = os.path.getmtime(file_path)
            return time.strftime("%d.%m.%Y %H:%M", time.localtime(timestamp))
        except:
            return "Bilinmiyor"
    
    def is_hidden_file(self, filename, file_path=None):
        """Gizli dosya kontrol√º - Ana programdan alƒ±ndƒ±"""
        # Windows gizli dosyalarƒ±
        if filename.startswith('.'):
            return True
        
        # Sistem dosyalarƒ±
        system_files = [
            'thumbs.db', 'desktop.ini', 'folder.jpg', 'folder.png',
            'albumartsmall.jpg', 'albumart_{', '.ds_store',
            'system volume information', '$recycle.bin', 'recycler',
            'pagefile.sys', 'hiberfil.sys', 'swapfile.sys'
        ]
        
        if filename.lower() in system_files:
            return True
        
        # Ge√ßici dosyalar
        temp_extensions = ['.tmp', '.temp', '.bak', '.old', '.cache', '.log']
        if any(filename.lower().endswith(ext) for ext in temp_extensions):
            return True
        
        # Windows gizli dosya attribute kontrol√º
        if file_path and os.path.exists(file_path):
            try:
                import stat
                file_stat = os.stat(file_path)
                # Windows'ta gizli dosya kontrol√º
                if hasattr(stat, 'FILE_ATTRIBUTE_HIDDEN'):
                    return bool(file_stat.st_file_attributes & stat.FILE_ATTRIBUTE_HIDDEN)
            except:
                pass
        
        return False
    
    def format_size(self, size_bytes):
        """Dosya boyutunu formatla"""
        if size_bytes == 0:
            return "0 B"
        
        size_names = ["B", "KB", "MB", "GB", "TB"]
        import math
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"
    
    def get_sort_key(self, item):
        """Sƒ±ralama anahtarƒ±"""
        item_name, item_type, size, modified, full_path, is_dir = item
        
        if self.sort_column == '#0':  # ƒ∞sim
            return (not is_dir, item_name.lower())
        elif self.sort_column == 'size':  # Boyut
            if is_dir:
                return (0, item_name.lower())
            try:
                return (1, self.parse_size_string(size))
            except:
                return (1, 0)
        elif self.sort_column == 'type':  # T√ºr
            return (not is_dir, item_type.lower())
        elif self.sort_column == 'modified':  # Deƒüi≈ütirilme
            return (not is_dir, modified)
        
        return (not is_dir, item_name.lower())
    
    def parse_size_string(self, size_str):
        """Boyut string'ini sayƒ±ya √ßevir"""
        if not size_str or size_str == "":
            return 0
        
        try:
            parts = size_str.split()
            if len(parts) != 2:
                return 0
            
            number = float(parts[0])
            unit = parts[1].upper()
            
            multipliers = {"B": 1, "KB": 1024, "MB": 1024**2, "GB": 1024**3, "TB": 1024**4}
            return number * multipliers.get(unit, 1)
        except:
            return 0
    
    def sort_tree(self, column):
        """Tree sƒ±ralama"""
        if self.sort_column == column:
            self.sort_reverse = not self.sort_reverse
        else:
            self.sort_column = column
            self.sort_reverse = False
        
        self.refresh_target(add_to_history=False)
    
    def on_target_double_click(self, event):
        """√áift tƒ±klama olayƒ±"""
        selection = self.gui.target_tree.selection()
        if not selection:
            return
        
        item = self.gui.target_tree.item(selection[0])
        item_name = item['text'].replace("üìÅ ", "").replace("üìÑ ", "")
        item_path = os.path.join(self.current_path, item_name)
        
        print(f"üñ±Ô∏è √áift tƒ±klama: {item_name} -> {item_path}")
        
        if os.path.isdir(item_path):
            # Klas√∂re gir
            print(f"üìÅ Klas√∂re giriliyor: {item_path}")
            self.add_to_history(self.current_path)
            self.current_path = item_path
            self.gui.current_path_var.set(item_path)
            self.refresh_target(add_to_history=False)
        else:
            # Dosyayƒ± a√ß
            try:
                print(f"üìÑ Dosya a√ßƒ±lƒ±yor: {item_path}")
                os.startfile(item_path)
            except Exception as e:
                print(f"‚ùå Dosya a√ßma hatasƒ±: {e}")
                messagebox.showerror("Hata", f"Dosya a√ßƒ±lamadƒ±: {e}")
    
    def show_context_menu(self, event):
        """Saƒü tƒ±k men√ºs√º"""
        try:
            # Se√ßili √∂ƒüeyi belirle
            item = self.gui.target_tree.identify_row(event.y)
            if item:
                self.gui.target_tree.selection_set(item)
                
            # Saƒü tƒ±k men√ºs√º olu≈ütur
            context_menu = tk.Menu(self.gui.root, tearoff=0)
            
            selection = self.gui.target_tree.selection()
            
            if selection:
                # Dosya/klas√∂r se√ßili
                context_menu.add_command(label="üîì A√ß", command=self.open_selected)
                context_menu.add_command(label="üîç Dosya Konumunu A√ß", command=self.open_file_location)
                context_menu.add_separator()
                context_menu.add_command(label="üìã Kopyala (Ctrl+C)", command=self.copy_selected)
                context_menu.add_command(label="‚úÇÔ∏è Kes (Ctrl+X)", command=self.cut_selected)
                
                # Yapƒ±≈ütƒ±rma - pano doluysa aktif
                paste_state = tk.NORMAL if self.clipboard else tk.DISABLED
                context_menu.add_command(label="üìÅ Yapƒ±≈ütƒ±r (Ctrl+V)", command=self.paste_selected, state=paste_state)
                
                context_menu.add_separator()
                context_menu.add_command(label="üóëÔ∏è Sil (Del)", command=self.delete_selected)
                context_menu.add_command(label="‚úèÔ∏è Yeniden Adlandƒ±r (F2)", command=self.rename_selected)
                context_menu.add_separator()
                
                # Tek dosya se√ßiliyse ek se√ßenekler
                if len(selection) == 1:
                    item_data = self.gui.target_tree.item(selection[0])
                    item_name = item_data['text'].replace("üìÅ ", "").replace("üìÑ ", "")
                    item_path = os.path.join(self.current_path, item_name)
                    
                    if os.path.isfile(item_path):
                        context_menu.add_command(label="üìä Dosya Bilgileri", command=self.show_file_info)
                        context_menu.add_command(label="üîÑ Dosya Hash", command=self.show_file_hash)
                    
                context_menu.add_command(label="üìã √ñzellikler", command=self.show_properties)
            else:
                # Bo≈ü alan
                context_menu.add_command(label="üìÅ Yapƒ±≈ütƒ±r (Ctrl+V)", command=self.paste_selected, 
                                       state=tk.NORMAL if self.clipboard else tk.DISABLED)
                context_menu.add_separator()
                context_menu.add_command(label="‚ûï Yeni Klas√∂r", command=self.create_folder)
                context_menu.add_command(label="üìÑ Yeni Dosya", command=self.create_new_file)
                context_menu.add_separator()
                context_menu.add_command(label="üîÑ Yenile (F5)", command=self.refresh_target)
                context_menu.add_separator()
                context_menu.add_command(label="üìã Klas√∂r √ñzellikeri", command=self.show_folder_properties)
            
            # Men√ºy√º g√∂ster
            context_menu.tk_popup(event.x_root, event.y_root)
        except Exception as e:
            print(f"Men√º hatasƒ±: {e}")
    
    def get_selected_items(self):
        """Se√ßili √∂ƒüeleri al"""
        selection = self.gui.target_tree.selection()
        items = []
        
        for item in selection:
            item_data = self.gui.target_tree.item(item)
            item_text = item_data['text'].replace("üìÅ ", "").replace("üìÑ ", "")
            item_path = os.path.join(self.current_path, item_text)
            items.append(item_path)
        
        return items
    
    def delete_selected(self):
        """Se√ßili dosyalarƒ± sil"""
        items = self.get_selected_items()
        if not items:
            messagebox.showwarning("Uyarƒ±", "Silinecek dosya se√ßin!")
            return
        
        # Onay al
        if len(items) == 1:
            message = f"'{os.path.basename(items[0])}' dosyasƒ±nƒ± silmek istediƒüinizden emin misiniz?"
        else:
            message = f"{len(items)} dosyayƒ± silmek istediƒüinizden emin misiniz?"
        
        if not messagebox.askyesno("Silme Onayƒ±", message):
            return
        
        # Sil
        deleted_count = 0
        for item_path in items:
            try:
                if os.path.isdir(item_path):
                    shutil.rmtree(item_path)
                else:
                    os.remove(item_path)
                deleted_count += 1
            except Exception as e:
                messagebox.showerror("Hata", f"'{os.path.basename(item_path)}' silinemedi: {e}")
        
        if deleted_count > 0:
            self.gui.status_var.set(f"{deleted_count} √∂ƒüe silindi.")
            self.refresh_target(add_to_history=False)
    
    def copy_selected(self):
        """Se√ßili dosyalarƒ± kopyala"""
        items = self.get_selected_items()
        if not items:
            messagebox.showwarning("Uyarƒ±", "Kopyalanacak dosya se√ßin!")
            return
        
        self.clipboard = items
        self.clipboard_operation = 'copy'
        self.gui.status_var.set(f"{len(items)} √∂ƒüe kopyalandƒ±.")
    
    def cut_selected(self):
        """Se√ßili dosyalarƒ± kes"""
        items = self.get_selected_items()
        if not items:
            messagebox.showwarning("Uyarƒ±", "Kesilecek dosya se√ßin!")
            return
        
        self.clipboard = items
        self.clipboard_operation = 'cut'
        self.gui.status_var.set(f"{len(items)} √∂ƒüe kesildi.")
    
    def paste_selected(self):
        """Dosyalarƒ± yapƒ±≈ütƒ±r"""
        if not self.clipboard:
            messagebox.showwarning("Uyarƒ±", "Yapƒ±≈ütƒ±rƒ±lacak dosya yok!")
            return
        
        pasted_count = 0
        for source_path in self.clipboard:
            try:
                filename = os.path.basename(source_path)
                target_path = os.path.join(self.current_path, filename)
                
                # Aynƒ± isimde dosya varsa numara ekle
                counter = 1
                base_name, ext = os.path.splitext(filename)
                while os.path.exists(target_path):
                    new_name = f"{base_name}_{counter}{ext}"
                    target_path = os.path.join(self.current_path, new_name)
                    counter += 1
                
                if self.clipboard_operation == 'copy':
                    if os.path.isdir(source_path):
                        shutil.copytree(source_path, target_path)
                    else:
                        shutil.copy2(source_path, target_path)
                elif self.clipboard_operation == 'cut':
                    shutil.move(source_path, target_path)
                
                pasted_count += 1
                
            except Exception as e:
                messagebox.showerror("Hata", f"'{os.path.basename(source_path)}' yapƒ±≈ütƒ±rƒ±lamadƒ±: {e}")
        
        if self.clipboard_operation == 'cut':
            self.clipboard = []
            self.clipboard_operation = None
        
        if pasted_count > 0:
            self.gui.status_var.set(f"{pasted_count} √∂ƒüe yapƒ±≈ütƒ±rƒ±ldƒ±.")
            self.refresh_target(add_to_history=False)
    
    def create_folder(self):
        """Yeni klas√∂r olu≈ütur"""
        folder_name = simpledialog.askstring("Yeni Klas√∂r", "Klas√∂r adƒ±nƒ± girin:")
        if folder_name:
            folder_path = os.path.join(self.current_path, folder_name)
            try:
                os.makedirs(folder_path, exist_ok=True)
                self.gui.status_var.set(f"'{folder_name}' klas√∂r√º olu≈üturuldu.")
                self.refresh_target(add_to_history=False)
            except Exception as e:
                messagebox.showerror("Hata", f"Klas√∂r olu≈üturulamadƒ±: {e}")
    
    def open_selected(self):
        """Se√ßili dosyayƒ± a√ß veya klas√∂re gir"""
        selection = self.gui.target_tree.selection()
        if not selection:
            messagebox.showwarning("Uyarƒ±", "A√ßƒ±lacak dosya/klas√∂r se√ßin!")
            return
        
        # ƒ∞lk se√ßili √∂ƒüeyi al
        item = self.gui.target_tree.item(selection[0])
        item_name = item['text'].replace("üìÅ ", "").replace("üìÑ ", "")
        item_path = os.path.join(self.current_path, item_name)
        
        if os.path.isdir(item_path):
            # Klas√∂re gir
            self.add_to_history(self.current_path)
            self.current_path = item_path
            self.gui.current_path_var.set(item_path)
            self.refresh_target(add_to_history=False)
        else:
            # Dosyayƒ± a√ß
            try:
                os.startfile(item_path)
            except Exception as e:
                messagebox.showerror("Hata", f"'{item_name}' a√ßƒ±lamadƒ±: {e}")
    
    def rename_selected(self):
        """Se√ßili dosyayƒ± yeniden adlandƒ±r"""
        items = self.get_selected_items()
        if not items:
            messagebox.showwarning("Uyarƒ±", "Yeniden adlandƒ±rƒ±lacak dosya se√ßin!")
            return
        
        if len(items) > 1:
            messagebox.showwarning("Uyarƒ±", "Tek dosya se√ßin!")
            return
        
        old_path = items[0]
        old_name = os.path.basename(old_path)
        
        new_name = simpledialog.askstring("Yeniden Adlandƒ±r", "Yeni adƒ± girin:", initialvalue=old_name)
        if new_name and new_name != old_name:
            new_path = os.path.join(os.path.dirname(old_path), new_name)
            try:
                os.rename(old_path, new_path)
                self.gui.status_var.set(f"'{old_name}' -> '{new_name}' olarak deƒüi≈ütirildi.")
                self.refresh_target(add_to_history=False)
            except Exception as e:
                messagebox.showerror("Hata", f"Yeniden adlandƒ±rƒ±lamadƒ±: {e}")
    
    def show_properties(self):
        """Dosya √∂zelliklerini g√∂ster"""
        items = self.get_selected_items()
        if not items:
            messagebox.showwarning("Uyarƒ±", "√ñzelliklerini g√∂rmek istediƒüiniz dosyayƒ± se√ßin!")
            return
        
        if len(items) > 1:
            messagebox.showwarning("Uyarƒ±", "Tek dosya se√ßin!")
            return
        
        file_path = items[0]
        try:
            stat = os.stat(file_path)
            import time
            
            properties = f"""Dosya √ñzellikleri:
            
Adƒ±: {os.path.basename(file_path)}
Yol: {file_path}
Boyut: {self.format_size(stat.st_size)}
Olu≈üturulma: {time.strftime("%d.%m.%Y %H:%M:%S", time.localtime(stat.st_ctime))}
Deƒüi≈ütirilme: {time.strftime("%d.%m.%Y %H:%M:%S", time.localtime(stat.st_mtime))}
Eri≈üim: {time.strftime("%d.%m.%Y %H:%M:%S", time.localtime(stat.st_atime))}
T√ºr: {"Klas√∂r" if os.path.isdir(file_path) else "Dosya"}
"""
            
            messagebox.showinfo("√ñzellikler", properties)
        except Exception as e:
            messagebox.showerror("Hata", f"√ñzellikler alƒ±nƒ±rken hata: {e}")
    
    def get_file_hash(self, file_path):
        """Dosya hash'ini hesapla - Ana programdan alƒ±ndƒ±"""
        try:
            hash_md5 = hashlib.md5()
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except Exception as e:
            return f"Hata: {e}"
    
    def is_file_locked(self, file_path):
        """Dosya kilitli mi kontrol et"""
        try:
            with open(file_path, 'r+b'):
                return False
        except (IOError, OSError):
            return True
    
    def copy_file_optimized(self, source_path, target_path):
        """Optimize edilmi≈ü dosya kopyalama"""
        try:
            # Dosya kilitli mi kontrol et
            if self.is_file_locked(source_path):
                return False, "Dosya kullanƒ±mda"
            
            # B√ºy√ºk dosyalar i√ßin chunk-based kopyalama
            file_size = os.path.getsize(source_path)
            if file_size > 50 * 1024 * 1024:  # 50MB'dan b√ºy√ºkse
                return self.copy_file_chunked(source_path, target_path)
            else:
                shutil.copy2(source_path, target_path)
                return True, "Ba≈üarƒ±lƒ±"
        except Exception as e:
            return False, str(e)
    
    def copy_file_chunked(self, source_path, target_path):
        """Chunk-based dosya kopyalama"""
        try:
            chunk_size = 1024 * 1024  # 1MB chunks
            with open(source_path, 'rb') as src, open(target_path, 'wb') as dst:
                while True:
                    chunk = src.read(chunk_size)
                    if not chunk:
                        break
                    dst.write(chunk)
            return True, "Ba≈üarƒ±lƒ±"
        except Exception as e:
            return False, str(e)
    
    def load_settings(self):
        """Ayarlarƒ± y√ºkle"""
        try:
            if os.path.exists('file_manager_settings.json'):
                with open('file_manager_settings.json', 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                    
                # Son hedef klas√∂r√º y√ºkle
                if 'target_path' in settings:
                    self.target_path = settings['target_path']
                    self.current_path = self.target_path
                    self.gui.target_var.set(self.target_path)
                    self.gui.current_path_var.set(self.current_path)
                    
        except Exception as e:
            print(f"Ayarlar y√ºklenirken hata: {e}")
    
    def save_settings(self):
        """Ayarlarƒ± kaydet"""
        try:
            settings = {
                'target_path': self.target_path,
                'current_path': self.current_path
            }
            
            with open('file_manager_settings.json', 'w', encoding='utf-8') as f:
                json.dump(settings, f, indent=2, ensure_ascii=False)
                
        except Exception as e:
            print(f"Ayarlar kaydedilirken hata: {e}")
    
    def setup_drag_drop(self):
        """S√ºr√ºkleyip bƒ±rakma √∂zelliƒüini ayarla"""
        # S√ºr√ºkleme ba≈ülangƒ±cƒ±
        self.gui.target_tree.bind('<Button-1>', self.on_drag_start)
        self.gui.target_tree.bind('<B1-Motion>', self.on_drag_motion)
        self.gui.target_tree.bind('<ButtonRelease-1>', self.on_drag_end)
        
    def on_drag_start(self, event):
        """S√ºr√ºkleme ba≈ülangƒ±cƒ±"""
        item = self.gui.target_tree.identify_row(event.y)
        if item:
            self.drag_data["item"] = item
            self.drag_data["x"] = event.x
            self.drag_data["y"] = event.y
            # ƒ∞lk s√ºr√ºkleme cursor'u
            self.gui.target_tree.config(cursor="hand2")
            
    def on_drag_motion(self, event):
        """S√ºr√ºkleme hareketi"""
        if self.drag_data["item"]:
            # S√ºr√ºklenen √∂ƒüeyi vurgula
            self.gui.target_tree.selection_set(self.drag_data["item"])
            
            # Cursor'ƒ± ta≈üƒ±ma ikonu yap
            self.gui.target_tree.config(cursor="fleur")  # Ta≈üƒ±ma cursor'u
            
            # Hedef kontrol√º - eƒüer klas√∂r √ºzerindeyse farklƒ± cursor
            target_item = self.gui.target_tree.identify_row(event.y)
            if target_item and target_item != self.drag_data["item"]:
                target_item_data = self.gui.target_tree.item(target_item)
                target_name = target_item_data['text'].replace("üìÅ ", "").replace("üìÑ ", "")
                target_path = os.path.join(self.current_path, target_name)
                
                if os.path.isdir(target_path):
                    self.gui.target_tree.config(cursor="dotbox")  # Hedef klas√∂r cursor'u
                else:
                    self.gui.target_tree.config(cursor="X_cursor")  # Ge√ßersiz hedef
            
    def on_drag_end(self, event):
        """S√ºr√ºkleme biti≈üi"""
        if not self.drag_data["item"]:
            return
            
        # Hedef √∂ƒüeyi bul
        target_item = self.gui.target_tree.identify_row(event.y)
        
        if target_item and target_item != self.drag_data["item"]:
            source_item = self.gui.target_tree.item(self.drag_data["item"])
            target_item_data = self.gui.target_tree.item(target_item)
            
            source_name = source_item['text'].replace("üìÅ ", "").replace("üìÑ ", "")
            target_name = target_item_data['text'].replace("üìÅ ", "").replace("üìÑ ", "")
            
            source_path = os.path.join(self.current_path, source_name)
            target_path = os.path.join(self.current_path, target_name)
            
            # Hedef bir klas√∂r m√º kontrol et
            if os.path.isdir(target_path):
                self.move_file_to_folder(source_path, target_path)
        
        # S√ºr√ºkleme verilerini temizle
        self.drag_data = {"item": None, "x": 0, "y": 0}
        
        # Cursor'ƒ± normale d√∂nd√ºr
        self.gui.target_tree.config(cursor="")
        
    def move_file_to_folder(self, source_path, target_folder):
        """Dosya/klas√∂r√º hedef klas√∂re ta≈üƒ±"""
        source_name = os.path.basename(source_path)
        is_folder = os.path.isdir(source_path)
        
        try:
            if is_folder:
                # Klas√∂r ta≈üƒ±ma i√ßin √∂zel dialog
                choice = self._ask_folder_move_method(source_name, target_folder)
                if choice == "cancel":
                    return
                elif choice == "complete":
                    self._move_complete_folder(source_path, target_folder)
                elif choice == "categorize":
                    self._move_folder_with_categorization(source_path, target_folder)
            else:
                # Normal dosya ta≈üƒ±ma - basit onay dialog'u
                message = f"'{source_name}' dosyasƒ±nƒ± '{os.path.basename(target_folder)}' klas√∂r√ºne ta≈üƒ±mak istiyor musunuz?"
                if messagebox.askyesno("Ta≈üƒ±ma Onayƒ±", message):
                    self._move_single_file(source_path, target_folder)
                else:
                    return
            
            self.refresh_target()
            self.gui.status_var.set(f"'{source_name}' ba≈üarƒ±yla ta≈üƒ±ndƒ±.")
                
        except Exception as e:
            messagebox.showerror("Hata", f"Ta≈üƒ±ma hatasƒ±: {e}")
    
    def _ask_folder_move_method(self, source_name, target_folder):
        """Klas√∂r ta≈üƒ±ma y√∂ntemi i√ßin kullanƒ±cƒ±ya sor"""
        import tkinter as tk
        from tkinter import ttk
        
        # √ñzel dialog olu≈ütur
        dialog = tk.Toplevel(self.gui.root)
        dialog.title("Klas√∂r Ta≈üƒ±ma Y√∂ntemi")
        dialog.geometry("650x500")
        dialog.transient(self.gui.root)
        dialog.grab_set()
        
        # Dialog'u merkeze yerle≈ütir
        dialog.geometry("+%d+%d" % (self.gui.root.winfo_rootx() + 50, self.gui.root.winfo_rooty() + 50))
        
        result = {"choice": "cancel"}  # Default
        
        # ƒ∞√ßerik
        main_frame = ttk.Frame(dialog)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Ba≈ülƒ±k
        title_label = ttk.Label(main_frame, text=f"üìÅ '{source_name}' klas√∂r√ºn√º nasƒ±l ta≈üƒ±mak istiyorsunuz?", 
                               font=("Arial", 12, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Hedef bilgisi
        target_label = ttk.Label(main_frame, text=f"üéØ Hedef: {os.path.basename(target_folder)}", font=("Arial", 10))
        target_label.pack(pady=(0, 20))
        
        # Se√ßenekler
        option_frame = ttk.Frame(main_frame)
        option_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 20))
        
        # Radio button deƒüi≈ükeni
        choice_var = tk.StringVar(value="complete")
        
        # Se√ßenek 1: Komple ta≈üƒ±
        complete_frame = ttk.LabelFrame(option_frame, text="üóÇÔ∏è Klas√∂r√º Komple Ta≈üƒ±", padding=15)
        complete_frame.pack(fill=tk.X, pady=(0, 15))
        
        complete_radio = ttk.Radiobutton(complete_frame, text="Bu se√ßeneƒüi se√ß", 
                                       variable=choice_var, value="complete")
        complete_radio.pack(anchor=tk.W)
        
        ttk.Label(complete_frame, text="‚Ä¢ Klas√∂r yapƒ±sƒ±nƒ± korur\n‚Ä¢ T√ºm alt klas√∂rler ve dosyalar olduƒüu gibi ta≈üƒ±nƒ±r\n‚Ä¢ Hƒ±zlƒ± i≈ülem", 
                 font=("Arial", 9)).pack(anchor=tk.W, pady=(8, 0))
        
        # Se√ßenek 2: Kategorilere g√∂re organize et
        categorize_frame = ttk.LabelFrame(option_frame, text="üìÇ ƒ∞√ßeriƒüi Kategorilere G√∂re Organize Et", padding=15)
        categorize_frame.pack(fill=tk.X)
        
        categorize_radio = ttk.Radiobutton(categorize_frame, text="Bu se√ßeneƒüi se√ß", 
                                         variable=choice_var, value="categorize")
        categorize_radio.pack(anchor=tk.W)
        
        ttk.Label(categorize_frame, text="‚Ä¢ Dosyalar uzantƒ±larƒ±na g√∂re kategorilere ayrƒ±lƒ±r\n‚Ä¢ Mevcut klas√∂r yapƒ±sƒ± ile birle≈ütirilir\n‚Ä¢ Duplikat kontrol√º yapƒ±lƒ±r", 
                 font=("Arial", 9)).pack(anchor=tk.W, pady=(8, 0))
        
        # Butonlar
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(40, 0))
        
        def on_ok():
            result["choice"] = choice_var.get()
            dialog.destroy()
            
        def on_cancel():
            result["choice"] = "cancel"
            dialog.destroy()
        
        # Butonlarƒ± daha b√ºy√ºk ve g√∂r√ºn√ºr yap
        ok_button = ttk.Button(button_frame, text="‚úÖ Tamam", command=on_ok)
        ok_button.pack(side=tk.LEFT, padx=(0, 30), ipadx=25, ipady=8)
        
        cancel_button = ttk.Button(button_frame, text="‚ùå ƒ∞ptal", command=on_cancel)
        cancel_button.pack(side=tk.RIGHT, ipadx=25, ipady=8)
        
        # Enter ve Escape tu≈ü baƒülamalarƒ±
        dialog.bind('<Return>', lambda e: on_ok())
        dialog.bind('<Escape>', lambda e: on_cancel())
        
        # Focus ayarla
        ok_button.focus_set()
        
        # Dialog'u bekle
        dialog.wait_window()
        
        return result["choice"]
    
    def _move_complete_folder(self, source_path, target_folder):
        """Klas√∂r√º komple ta≈üƒ± (yapƒ±yƒ± koru)"""
        folder_name = os.path.basename(source_path)
        target_path = os.path.join(target_folder, folder_name)
        
        # Aynƒ± isimde klas√∂r varsa numara ekle
        counter = 1
        base_target = target_path
        while os.path.exists(target_path):
            target_path = f"{base_target}_{counter}"
            counter += 1
        
        # Klas√∂r√º ta≈üƒ±
        shutil.move(source_path, target_path)
        print(f"üìÅ Klas√∂r komple ta≈üƒ±ndƒ±: {source_path} -> {target_path}")
    
    def _move_single_file(self, source_path, target_folder):
        """Tek dosyayƒ± ta≈üƒ±"""
        file_name = os.path.basename(source_path)
        new_path = os.path.join(target_folder, file_name)
        
        # Aynƒ± isimde dosya varsa numara ekle
        counter = 1
        base_name, ext = os.path.splitext(file_name)
        while os.path.exists(new_path):
            new_name = f"{base_name}_{counter}{ext}"
            new_path = os.path.join(target_folder, new_name)
            counter += 1
        
        shutil.move(source_path, new_path)
    
    def _move_folder_with_categorization(self, source_folder, target_folder):
        """Klas√∂r√º kategorilere g√∂re organize ederek ta≈üƒ±"""
        print(f"üóÇÔ∏è Klas√∂r kategorilere g√∂re ta≈üƒ±nƒ±yor: {source_folder} -> {target_folder}")
        
        # Hedef klas√∂r analizi yap (kaynak klas√∂r√º hari√ß tut)
        target_analysis = self._analyze_target_folders_for_move(target_folder, exclude_folder=source_folder)
        
        # Klas√∂rdeki t√ºm dosyalarƒ± tara
        files_to_move = []
        
        for root, dirs, files in os.walk(source_folder):
            # Gizli klas√∂rleri atla
            dirs[:] = [d for d in dirs if not d.startswith('.')]
            
            for file in files:
                if not file.startswith('.'):  # Gizli dosyalarƒ± atla
                    file_path = os.path.join(root, file)
                    files_to_move.append(file_path)
        
        print(f"üìä Ta≈üƒ±nacak dosya sayƒ±sƒ±: {len(files_to_move)}")
        
        # Dosyalarƒ± kategorilerine g√∂re organize et
        moved_count = 0
        duplicate_count = 0
        
        for file_path in files_to_move:
            try:
                # Dosya kategorisini belirle
                category, category_info = self.get_file_category(file_path)
                file_ext = os.path.splitext(file_path)[1].lower()
                
                # Hedef klas√∂rde uygun klas√∂r var mƒ± kontrol et
                suggested_folder = self._find_suitable_target_folder_for_move(file_ext, target_analysis)
                
                if suggested_folder:
                    # Mevcut klas√∂r bulundu - doƒürudan o klas√∂re yerle≈ütir
                    final_target_folder = suggested_folder
                    print(f"üìÅ {file_ext} dosyasƒ± mevcut klas√∂re yerle≈ütirilecek: {suggested_folder}")
                else:
                    # Standart kategori kullan - yeni klas√∂r olu≈ütur
                    category_folder = os.path.join(target_folder, category_info['folder'])
                    
                    # Alt kategori klas√∂r√º
                    subfolder = file_ext.replace('.', '').upper() if file_ext else 'Uzantisiz'
                    final_target_folder = os.path.join(category_folder, subfolder)
                    print(f"üìÅ {file_ext} dosyasƒ± yeni kategori klas√∂r√ºne yerle≈ütirilecek: {category_info['folder']}/{subfolder}")
                
                # Klas√∂rleri olu≈ütur
                os.makedirs(final_target_folder, exist_ok=True)
                
                # Dosya adƒ± ve hedef yol
                file_name = os.path.basename(file_path)
                target_file_path = os.path.join(final_target_folder, file_name)
                
                # Geli≈ümi≈ü duplikat kontrol√º
                duplicate_found = self._check_for_duplicates_in_target(file_path, final_target_folder)
                
                if duplicate_found:
                    # Duplikat dosya bulundu
                    if self._handle_duplicate_file(file_path, duplicate_found):
                        moved_count += 1
                    else:
                        duplicate_count += 1
                        print(f"‚è≠Ô∏è Duplikat atlandƒ±: {file_name}")
                else:
                    # Dosyayƒ± ta≈üƒ±
                    shutil.move(file_path, target_file_path)
                    moved_count += 1
                    print(f"‚úÖ Ta≈üƒ±ndƒ±: {file_name} -> {final_target_folder}")
                
            except Exception as e:
                print(f"‚ùå Hata: {file_path} ta≈üƒ±namadƒ± - {e}")
                continue
        
        # Kaynak klas√∂r√º sil (bo≈üsa)
        try:
            if not os.listdir(source_folder):
                os.rmdir(source_folder)
                print(f"üóëÔ∏è Bo≈ü kaynak klas√∂r silindi: {source_folder}")
        except:
            pass
        
        print(f"üìà Sonu√ß: {moved_count} dosya ta≈üƒ±ndƒ±, {duplicate_count} duplikat atlandƒ±")
    
    def _analyze_target_folders_for_move(self, target_folder, exclude_folder=None):
        """Hedef klas√∂rdeki mevcut klas√∂rleri analiz et (drag & drop i√ßin)"""
        folder_analysis = {}
        
        if not os.path.exists(target_folder):
            return folder_analysis
        
        print("üîç Hedef klas√∂r analizi ba≈ülatƒ±lƒ±yor...")
        
        # Sistem klas√∂rlerini hari√ß tut
        system_folders = {
            'system volume information', '$recycle.bin', 'recycler',
            'windows', 'program files', 'program files (x86)', 'programdata',
            'users', 'temp', 'tmp', 'cache', '.git', '.svn', 'node_modules',
            '__pycache__', '.vscode', '.idea'
        }
        
        try:
            # T√ºm klas√∂rleri recursive olarak analiz et (3 seviye derinlik)
            for root, dirs, files in os.walk(target_folder):
                # Derinlik kontrol√º
                current_level = root.count(os.sep) - target_folder.count(os.sep)
                if current_level >= 3:
                    dirs.clear()  # Daha derine inme
                    continue
                
                # Gizli ve sistem klas√∂rlerini atla
                dirs[:] = [d for d in dirs if not d.startswith('.') and d.lower() not in system_folders]
                
                # Kaynak klas√∂r√º hari√ß tut
                if exclude_folder and os.path.exists(exclude_folder):
                    try:
                        if os.path.samefile(root, exclude_folder):
                            print(f"‚è≠Ô∏è Kaynak klas√∂r atlandƒ±: {os.path.basename(root)}")
                            dirs.clear()  # Alt klas√∂rlerini de atla
                            continue
                    except:
                        if os.path.basename(root) == os.path.basename(exclude_folder):
                            print(f"‚è≠Ô∏è Kaynak klas√∂r atlandƒ±: {os.path.basename(root)}")
                            dirs.clear()
                            continue
                
                # Bu klas√∂rde dosya var mƒ± kontrol et
                folder_extensions = {}
                for file in files:
                    if not file.startswith('.'):
                        file_ext = os.path.splitext(file)[1].lower()
                        if file_ext:
                            if file_ext not in folder_extensions:
                                folder_extensions[file_ext] = 0
                            folder_extensions[file_ext] += 1
                
                # Eƒüer bu klas√∂rde dosya varsa analiz sonu√ßlarƒ±na ekle
                if folder_extensions and root != target_folder:
                    # Relative path olu≈ütur
                    rel_path = os.path.relpath(root, target_folder)
                    folder_analysis[rel_path] = {
                        'path': root,
                        'extensions': folder_extensions,
                        'file_count': len(folder_extensions)
                    }
                    print(f"üìÇ {rel_path}: {list(folder_extensions.keys())} uzantƒ±larƒ± bulundu")
        
        except Exception as e:
            print(f"‚ùå Hedef klas√∂r analizi hatasƒ±: {e}")
        
        return folder_analysis
    
    def _analyze_folder_extensions_for_move(self, folder_path, max_depth=5):
        """Klas√∂rdeki dosya uzantƒ±larƒ±nƒ± analiz et (drag & drop i√ßin - derin tarama)"""
        extensions = {}
        
        try:
            # os.walk ile t√ºm alt klas√∂rleri tara
            for root, dirs, files in os.walk(folder_path):
                # Derinlik kontrol√º
                current_level = root.count(os.sep) - folder_path.count(os.sep)
                if current_level >= max_depth:
                    continue
                
                # Gizli ve sistem klas√∂rlerini atla
                dirs[:] = [d for d in dirs if not d.startswith('.') and not self._is_system_folder_for_move(d)]
                
                # Dosyalarƒ± analiz et
                for file in files:
                    if not file.startswith('.'):
                        file_ext = os.path.splitext(file)[1].lower()
                        if file_ext:
                            if file_ext not in extensions:
                                extensions[file_ext] = 0
                            extensions[file_ext] += 1
        
        except Exception as e:
            print(f"‚ùå Klas√∂r uzantƒ± analizi hatasƒ±: {folder_path} - {e}")
        
        return extensions
    
    def _is_system_folder_for_move(self, folder_name):
        """Sistem klas√∂r√º m√º kontrol et (drag & drop i√ßin)"""
        system_folders = {
            'system volume information', '$recycle.bin', 'recycler',
            'windows', 'program files', 'program files (x86)', 'programdata',
            'users', 'temp', 'tmp', 'cache', '.git', '.svn', 'node_modules',
            '__pycache__', '.vscode', '.idea', 'appdata', 'application data'
        }
        return folder_name.lower() in system_folders
    
    def _find_suitable_target_folder_for_move(self, extension, target_analysis):
        """Uzantƒ± i√ßin uygun hedef klas√∂r bul (drag & drop i√ßin)"""
        if not extension or not target_analysis:
            return None
        
        # En uygun klas√∂r√º bul
        best_folder = None
        best_score = 0
        
        # Dosyanƒ±n kategorisini belirle
        category, _ = self.get_file_category(f"test{extension}")
        category_keywords = {
            'audio': ['m√ºzik', 'ses', 'music', 'audio', 'sound'],
            'video': ['video', 'film', 'movie', 'sinema'],
            'images': ['resim', 'foto', 'image', 'picture', 'photo'],
            'documents': ['belge', 'doc', 'document', 'text', 'yazƒ±'],
            'archives': ['ar≈üiv', 'archive', 'zip', 'sƒ±kƒ±≈ütƒ±r'],
            'programs': ['program', 'uygulama', 'app', 'software'],
            'cad': ['cad', '√ßizim', 'tasarƒ±m', 'design']
        }
        
        for folder_name, folder_info in target_analysis.items():
            extensions = folder_info['extensions']
            score = 0
            
            # 1. Bu uzantƒ± bu klas√∂rde var mƒ± VE klas√∂r adƒ± uzantƒ±yla e≈üle≈üiyor mu?
            if extension in extensions:
                ext_name = extension.replace('.', '').upper()
                folder_upper = folder_name.upper()
                
                # Klas√∂r adƒ±nda uzantƒ± ge√ßiyor mu kontrol et
                if ext_name in folder_upper or folder_upper.endswith(ext_name):
                    score = extensions[extension] + 100
                    print(f"üéØ {extension} uzantƒ±sƒ± {folder_name} klas√∂r√ºnde bulundu VE klas√∂r adƒ± e≈üle≈üiyor (tam e≈üle≈üme)")
                else:
                    # Uzantƒ± var ama klas√∂r adƒ± e≈üle≈ümiyor - d√º≈ü√ºk puan
                    score = extensions[extension] * 5
                    print(f"‚ö†Ô∏è {extension} uzantƒ±sƒ± {folder_name} klas√∂r√ºnde var ama klas√∂r adƒ± e≈üle≈ümiyor")
            
            # 2. Aynƒ± kategorideki ba≈üka uzantƒ±lar var mƒ±?
            elif category in category_keywords:
                # Aynƒ± kategorideki diƒüer uzantƒ±larƒ± kontrol et
                same_category_extensions = []
                for cat, info in self.get_file_categories().items():
                    if cat == category:
                        same_category_extensions = info['extensions']
                        break
                
                # Bu klas√∂rde aynƒ± kategoriden uzantƒ± var mƒ±?
                for ext in same_category_extensions:
                    if ext in extensions:
                        score += extensions[ext] * 10  # Kategori e≈üle≈ümesi i√ßin puan
                        print(f"üîó {extension} i√ßin {folder_name} klas√∂r√ºnde aynƒ± kategori uzantƒ±sƒ± bulundu: {ext}")
                        break
            
            # 3. Klas√∂r adƒ±nda kategori kelimesi ge√ßiyor mu?
            if category in category_keywords:
                for keyword in category_keywords[category]:
                    if keyword in folder_name.lower():
                        score += 50
                        print(f"üìù {folder_name} klas√∂r adƒ±nda kategori kelimesi bulundu: {keyword}")
                        break
            
            # 4. Klas√∂r adƒ±nda uzantƒ± ge√ßiyor mu?
            ext_name = extension.replace('.', '').upper()
            if ext_name in folder_name.upper():
                score += 100
                print(f"üìù {folder_name} klas√∂r adƒ±nda uzantƒ± bulundu: {ext_name}")
            
            # 5. Dosya sayƒ±sƒ± bonus
            file_count = folder_info.get('file_count', 0)
            if file_count > 10:
                score += 20
            elif file_count > 5:
                score += 10
            
            if score > best_score:
                best_score = score
                best_folder = folder_info['path']
        
        # Sadece ger√ßek tam e≈üle≈üme kabul et (uzantƒ± var VE klas√∂r adƒ± e≈üle≈üiyor)
        # Skor >= 100 VE uzantƒ± + klas√∂r adƒ± e≈üle≈ümesi olmalƒ±
        if best_score >= 100:
            # Ger√ßek tam e≈üle≈üme mi kontrol et
            best_folder_name = None
            best_folder_extensions = None
            for folder_name, folder_info in target_analysis.items():
                if folder_info['path'] == best_folder:
                    best_folder_name = folder_name
                    best_folder_extensions = folder_info['extensions']
                    break
            
            if best_folder_extensions and extension in best_folder_extensions:
                ext_name = extension.replace('.', '').upper()
                # Klas√∂r adƒ±nƒ±n son kƒ±smƒ±nƒ± kontrol et (√∂rn: "Resimler/SVG" -> "SVG")
                folder_basename = os.path.basename(best_folder_name) if best_folder_name else ""
                if (ext_name in best_folder_name.upper() or 
                    best_folder_name.upper().endswith(ext_name) or
                    ext_name in folder_basename.upper() or
                    folder_basename.upper() == ext_name):
                    print(f"üìÅ {extension} i√ßin ger√ßek tam e≈üle≈üme bulundu: {os.path.basename(best_folder)} (skor: {best_score})")
                    return best_folder
        
        print(f"‚ùå {extension} i√ßin ger√ßek tam e≈üle≈üme bulunamadƒ± - yeni klas√∂r olu≈üturulacak")
        return None
    
    def _check_for_duplicates_in_target(self, source_file, target_folder):
        """Hedef klas√∂rde duplikat dosya var mƒ± kontrol et (hash bazlƒ±)"""
        if not os.path.exists(target_folder):
            return None
        
        source_name = os.path.basename(source_file)
        source_size = os.path.getsize(source_file)
        
        try:
            # Hedef klas√∂rdeki dosyalarƒ± kontrol et
            for existing_file in os.listdir(target_folder):
                existing_path = os.path.join(target_folder, existing_file)
                
                if os.path.isfile(existing_path):
                    # ƒ∞sim kontrol√º
                    if existing_file == source_name:
                        print(f"üîç Aynƒ± isimli dosya bulundu: {existing_file}")
                        return existing_path
                    
                    # Boyut kontrol√º (hƒ±zlƒ± √∂n kontrol)
                    if os.path.getsize(existing_path) == source_size:
                        # Hash kontrol√º (kesin kontrol)
                        if self._files_are_identical(source_file, existing_path):
                            print(f"üîç Aynƒ± i√ßerikli dosya bulundu: {existing_file}")
                            return existing_path
        
        except Exception as e:
            print(f"‚ùå Duplikat kontrol hatasƒ±: {e}")
        
        return None
    
    def _files_are_identical(self, file1, file2):
        """ƒ∞ki dosyanƒ±n i√ßeriƒüi aynƒ± mƒ± kontrol et"""
        try:
            # Hƒ±zlƒ± boyut kontrol√º
            if os.path.getsize(file1) != os.path.getsize(file2):
                return False
            
            # Hash kar≈üƒ±la≈ütƒ±rmasƒ±
            hash1 = self._calculate_file_hash(file1)
            hash2 = self._calculate_file_hash(file2)
            
            return hash1 == hash2 and hash1 is not None
        
        except Exception as e:
            print(f"‚ùå Dosya kar≈üƒ±la≈ütƒ±rma hatasƒ±: {e}")
            return False
    
    def _calculate_file_hash(self, file_path, chunk_size=8192):
        """Dosya hash'ini hesapla"""
        try:
            import hashlib
            hash_md5 = hashlib.md5()
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(chunk_size), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except Exception as e:
            print(f"‚ùå Hash hesaplama hatasƒ±: {file_path} - {e}")
            return None
    
    def _handle_duplicate_file(self, source_file, target_file):
        """Duplikat dosyayƒ± i≈üle"""
        # Duplikat i≈ülem se√ßeneƒüini al
        duplicate_action = self.gui.duplicate_action.get()
        
        if duplicate_action == "skip":
            print(f"‚è≠Ô∏è Duplikat atlandƒ±: {os.path.basename(source_file)}")
            return False
        elif duplicate_action == "copy":
            # Numara ekleyerek kopyala
            counter = 1
            base_name, ext = os.path.splitext(target_file)
            new_target = f"{base_name}_{counter}{ext}"
            
            while os.path.exists(new_target):
                counter += 1
                new_target = f"{base_name}_{counter}{ext}"
            
            shutil.move(source_file, new_target)
            print(f"üìã Duplikat ta≈üƒ±ndƒ±: {os.path.basename(new_target)}")
            return True
        else:  # ask
            # Kullanƒ±cƒ±ya sor
            response = messagebox.askyesnocancel(
                "Duplikat Dosya",
                f"'{os.path.basename(source_file)}' dosyasƒ± zaten mevcut.\n\n"
                "Evet: Numara ekleyerek ta≈üƒ±\n"
                "Hayƒ±r: Atla\n"
                "ƒ∞ptal: ƒ∞≈ülemi durdur"
            )
            
            if response is True:  # Evet
                counter = 1
                base_name, ext = os.path.splitext(target_file)
                new_target = f"{base_name}_{counter}{ext}"
                
                while os.path.exists(new_target):
                    counter += 1
                    new_target = f"{base_name}_{counter}{ext}"
                
                shutil.move(source_file, new_target)
                return True
            elif response is False:  # Hayƒ±r
                return False
            else:  # ƒ∞ptal
                raise Exception("ƒ∞≈ülem kullanƒ±cƒ± tarafƒ±ndan iptal edildi")
        
        return False
    
    def open_file_location(self):
        """Dosya konumunu a√ß"""
        selection = self.gui.target_tree.selection()
        if not selection:
            messagebox.showwarning("Uyarƒ±", "L√ºtfen bir dosya se√ßin!")
            return
            
        item = self.gui.target_tree.item(selection[0])
        item_name = item['text'].replace("üìÅ ", "").replace("üìÑ ", "")
        item_path = os.path.join(self.current_path, item_name)
        
        try:
            # Windows Explorer'da dosya konumunu a√ß
            os.system(f'explorer /select,"{item_path}"')
        except Exception as e:
            messagebox.showerror("Hata", f"Dosya konumu a√ßƒ±lamadƒ±: {e}")
    
    def show_file_info(self):
        """Dosya bilgilerini g√∂ster"""
        selection = self.gui.target_tree.selection()
        if not selection:
            messagebox.showwarning("Uyarƒ±", "L√ºtfen bir dosya se√ßin!")
            return
            
        item = self.gui.target_tree.item(selection[0])
        item_name = item['text'].replace("üìÅ ", "").replace("üìÑ ", "")
        item_path = os.path.join(self.current_path, item_name)
        
        if not os.path.exists(item_path):
            messagebox.showerror("Hata", "Dosya bulunamadƒ±!")
            return
        
        try:
            stat_info = os.stat(item_path)
            file_size = self.format_size(stat_info.st_size)
            
            import datetime
            created_time = datetime.datetime.fromtimestamp(stat_info.st_ctime).strftime("%Y-%m-%d %H:%M:%S")
            modified_time = datetime.datetime.fromtimestamp(stat_info.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
            
            info_text = f"""üìÑ Dosya Bilgileri

üìÅ Dosya Adƒ±: {item_name}
üìÇ Tam Yol: {item_path}
üìä Boyut: {file_size}
üìÖ Olu≈üturulma: {created_time}
üîÑ Deƒüi≈ütirilme: {modified_time}
üîí ƒ∞zinler: {oct(stat_info.st_mode)[-3:]}"""

            if os.path.isfile(item_path):
                file_ext = os.path.splitext(item_name)[1].lower()
                category, _ = self.get_file_category(item_path)
                info_text += f"\nüè∑Ô∏è Kategori: {category.title()}"
                info_text += f"\nüìé Uzantƒ±: {file_ext if file_ext else 'Uzantƒ±sƒ±z'}"
            
            messagebox.showinfo("Dosya Bilgileri", info_text)
            
        except Exception as e:
            messagebox.showerror("Hata", f"Dosya bilgileri alƒ±namadƒ±: {e}")
    
    def show_file_hash(self):
        """Dosya hash'ini g√∂ster"""
        selection = self.gui.target_tree.selection()
        if not selection:
            messagebox.showwarning("Uyarƒ±", "L√ºtfen bir dosya se√ßin!")
            return
            
        item = self.gui.target_tree.item(selection[0])
        item_name = item['text'].replace("üìÅ ", "").replace("üìÑ ", "")
        item_path = os.path.join(self.current_path, item_name)
        
        if not os.path.isfile(item_path):
            messagebox.showwarning("Uyarƒ±", "Sadece dosyalar i√ßin hash hesaplanabilir!")
            return
        
        # Hash hesaplama dialog'u
        dialog = tk.Toplevel(self.gui.root)
        dialog.title("Hash Hesaplanƒ±yor...")
        dialog.geometry("400x150")
        dialog.transient(self.gui.root)
        dialog.grab_set()
        
        # Dialog'u merkeze yerle≈ütir
        dialog.geometry("+%d+%d" % (self.gui.root.winfo_rootx() + 50, self.gui.root.winfo_rooty() + 50))
        
        tk.Label(dialog, text=f"Hash hesaplanƒ±yor: {item_name}", font=("Arial", 10)).pack(pady=20)
        
        progress_var = tk.StringVar()
        progress_label = tk.Label(dialog, textvariable=progress_var)
        progress_label.pack(pady=10)
        
        result_var = tk.StringVar()
        
        def calculate_hash():
            try:
                progress_var.set("Hash hesaplanƒ±yor...")
                dialog.update()
                
                file_hash = self.get_file_hash(item_path)
                
                if file_hash:
                    result_var.set(file_hash)
                    progress_var.set("‚úÖ Hash hesaplandƒ±!")
                else:
                    progress_var.set("‚ùå Hash hesaplanamadƒ±!")
                    
            except Exception as e:
                progress_var.set(f"‚ùå Hata: {e}")
            
            dialog.after(1000, dialog.destroy)
            
            if result_var.get():
                messagebox.showinfo("Dosya Hash", f"üìÑ Dosya: {item_name}\nüîÑ MD5 Hash:\n{result_var.get()}")
        
        # Hash hesaplamayƒ± thread'de ba≈ülat
        import threading
        threading.Thread(target=calculate_hash, daemon=True).start()
    
    def create_new_file(self):
        """Yeni dosya olu≈ütur"""
        file_name = simpledialog.askstring("Yeni Dosya", "Dosya adƒ± (uzantƒ± ile):")
        if file_name:
            file_path = os.path.join(self.current_path, file_name)
            try:
                # Bo≈ü dosya olu≈ütur
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("")
                
                self.refresh_target()
                self.gui.status_var.set(f"'{file_name}' dosyasƒ± olu≈üturuldu.")
                
            except Exception as e:
                messagebox.showerror("Hata", f"Dosya olu≈üturulamadƒ±: {e}")
    
    def show_folder_properties(self):
        """Klas√∂r √∂zelliklerini g√∂ster"""
        try:
            # Klas√∂rdeki dosya sayƒ±sƒ±nƒ± hesapla
            total_files = 0
            total_folders = 0
            total_size = 0
            
            for root, dirs, files in os.walk(self.current_path):
                total_folders += len(dirs)
                total_files += len(files)
                
                for file in files:
                    try:
                        file_path = os.path.join(root, file)
                        total_size += os.path.getsize(file_path)
                    except:
                        continue
            
            folder_name = os.path.basename(self.current_path)
            if not folder_name:
                folder_name = self.current_path
            
            info_text = f"""üìÅ Klas√∂r √ñzellikleri

üìÇ Klas√∂r Adƒ±: {folder_name}
üìç Tam Yol: {self.current_path}
üìä Toplam Boyut: {self.format_size(total_size)}
üìÑ Dosya Sayƒ±sƒ±: {total_files}
üìÅ Klas√∂r Sayƒ±sƒ±: {total_folders}
üìà Toplam √ñƒüe: {total_files + total_folders}"""

            messagebox.showinfo("Klas√∂r √ñzellikleri", info_text)
            
        except Exception as e:
            messagebox.showerror("Hata", f"Klas√∂r bilgileri alƒ±namadƒ±: {e}") 